(in-package :graph-utils)

(defmethod bipartite? ((graph graph) &key show-partitions?)
  "Checks if a graph is bipartite.  If show-partitions? is T, return the
partitions."
  (let ((color-table (make-hash-table))
        (partition-table (make-hash-table))
        (queue (make-empty-queue))
        (components (find-components graph)))
    (flet ((set-color (node color)
             (setf (gethash node color-table) color))
           (color-of (node)
             (gethash node color-table))
           (partition-of (node)
             (gethash node partition-table))
           (set-partition (node p)
             (setf (gethash node partition-table) p)))
      (map-nodes #'(lambda (name n)
                     (declare (ignore name))
                     (set-partition n 0)
                     (set-color n :white))
                 graph)
      (dolist (component components)
        (let ((start (nth (random (length component)) component)))
          (set-partition start 1)
          (enqueue queue start)
          (set-color start :grey)
          (loop until (empty-queue? queue) do
               (let* ((node (dequeue queue)))
                 (dolist (neighbor (neighbors graph node))
                   (when (= (partition-of neighbor) (partition-of node))
                     (return-from bipartite? nil))
                   (when (eql :white (color-of neighbor))
                     (set-color neighbor :gray)
                     (set-partition neighbor (- 3 (partition-of node)))
                     (enqueue queue neighbor)))
                 (set-color node :black)))))
      (if show-partitions?
          (let ((a nil) (b nil))
            (maphash #'(lambda (node p)
                         (if (eq p 1)
                             (push node a)
                             (push node b)))
                     partition-table)
            (values a b))
          t))))

(defmethod compute-maximum-matching ((graph graph) v1 v2
                                     &key (algorithm :dinic))
  "Compute a maximum matching for the bipartite graph with partitions v1 and
v2."
  (let* ((flow-net (make-graph :directed? t)))
    (map-nodes #'(lambda (name id)
                   (declare (ignore name))
                   (add-node flow-net id))
               graph)
    (map-edges #'(lambda (n1 n2 w)
                   (declare (ignore w))
                   (if (member n1 v2)
                       (add-edge flow-net n2 n1 :weight 1)
                       (add-edge flow-net n1 n2 :weight 1)))
               graph)
    (let ((source (add-node flow-net :source))
          (sink (add-node flow-net :sink)))
      (dolist (node v1)
        (add-edge flow-net source node :weight 1))
      (dolist (node v2)
        (add-edge flow-net node sink :weight 1))
      ;;(visualize flow-net :render? t
      ;;:file (format nil "data/matching-~A.dot" algorithm))
      (multiple-value-bind (flow edges)
          (compute-maximum-flow flow-net source sink :algorithm algorithm)
        (values
         (mapcar #'(lambda (edge)
                     (subseq edge 0 2))
                 (remove-if #'(lambda (edge)
                                (or (/= 1 (nth 2 edge))
                                    (eq (first edge) source)
                                    (eq (first edge) sink)
                                    (eq (second edge) source)
                                    (eq (second edge) sink)))
                            edges))
         v1
         v2
         flow)))))

(defun test-bp ()
  (let ((graph
         (parse-pajek "/home/raison/work/graph-utils/data/bipartite1.net")))
    (multiple-value-bind (black white) (bipartite? graph :show-partitions? t)
      (if (and black white)
          (if (every #'evenp black)
              (multiple-value-bind (matching black white flow)
                  (compute-maximum-matching graph black white
                                            :algorithm :karzanov)
                (dbg "~A~%~A~%~A~%~A" matching black white flow)
                matching)
              (multiple-value-bind (matching black white flow)
                  (compute-maximum-matching graph white black
                                            :algorithm :karzanov)
                (dbg "~A~%~A~%~A~%~A" matching black white flow)
                matching))
          (error "~A is not bipartite!" graph)))))

